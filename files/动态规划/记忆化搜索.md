---
layout: post
title: 记忆化搜索
tag: 动态规划
---

## AcWing 901. 滑雪   [原题链接](https://www.acwing.com/problem/content/903/)

给定一个R行C列的矩阵，表示一个矩形网格滑雪场。

矩阵中第 i 行第 j 列的点表示滑雪场的第 i 行第 j 列区域的高度。

一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。

当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。

下面给出一个矩阵作为例子：

```
 1  2  3  4 5

16 17 18 19 6

15 24 25 20 7

14 23 22 21 8

13 12 11 10 9
```

在给定矩阵中，一条可行的滑行轨迹为24-17-2-1。

在给定矩阵中，最长的滑行轨迹为25-24-23-…-3-2-1，沿途共经过25个区域。

现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。

#### 输入格式

第一行包含两个整数R和C。

接下来R行，每行包含C个整数，表示完整的二维矩阵。

#### 输出格式

输出一个整数，表示可完成的最长滑雪长度。

#### 数据范围

1≤R,C≤3001≤R,C≤300,
0≤矩阵中整数≤100000≤矩阵中整数≤10000

#### 输入样例：

```
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
```

#### 输出样例：

```
25
```

## 题目思路

![ygsCk9.png](https://s3.ax1x.com/2021/02/17/ygsCk9.png)

```java
    private static int[][] dp;
    private static int[][] map;
    private static int n;
    private static int m;
    private static int[] dx = new int[]{-1, 0, 1, 0};
    private static int[] dy = new int[]{0, 1, 0, -1};
    private static int mnemonicSearch(int x, int y) {
        // 状态已经被算过了
        if (dp[x][y] != -1) {
            return dp[x][y];
        }
        dp[x][y] = 1;
        for (int i = 0; i < 4; i++) {
            int bx = x + dx[i];
            int by = y + dy[i];
            if (bx < 0 || by < 0 || bx >= n || by >= m || map[bx][by] >= map[x][y]) continue;
            dp[x][y] = Math.max(dp[x][y], mnemonicSearch(bx, by) + 1);
        }
        return dp[x][y];
    }
    public static void main(String[] args) {
        n = in.nextInt();
        m = in.nextInt();
        map = new int[n][m];
        dp = new int[n + 1][m + 1];
        for (int i = 0; i < n; i++) in.nextIntegerArray(map[i]);
        // 初始化所有状态，表示所有状态都没被更新过
        for (int i = 0; i < n + 1; i++) Arrays.fill(dp[i], -1);
        int res = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                res = Math.max(res, mnemonicSearch(i, j));
            }
        }
        out.println(res);
        out.flush();
        out.close();
    }
```

